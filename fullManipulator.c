#pragma config(Sensor, dgtl1, shoulderUpButton, sensorTouch)
#pragma config(Sensor, dgtl2, shoulderDownButton, sensorTouch)
#pragma config(Sensor, dgtl3, elbowUpButton, sensorTouch)
#pragma config(Sensor, dgtl4, elbowDownButton, sensorTouch)
#pragma config(Sensor, dgtl5, sonarC, sensorSONAR_cm)
#pragma config(Sensor, dgtl7, elbowLimit, sensorTouch)
#pragma config(Sensor, dgtl8, elbowEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl10, shoulderLimit, sensorTouch)
#pragma config(Sensor, dgtl11, shoulderEncoder, sensorQuadEncoder)
#pragma config(Motor, port2, shoulderM, tmotorServoContinuousRotation,
openLoop)
#pragma config(Motor, port3, elbowM, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor, port4, clawServo, tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//
//global variables
// Optical shaft encoder values the arm shouldnt go past
// Shoulder
int sUpperBound = -30;
int sLowerBound = 30;
//Elbow
int eUpperBound = 40;
int eLowerBound = -40;
//Limits for the claw servo
int clawOpen = 125;
int clawClose = -75;
bool clawFlip = false;
int sonarV = 10;
bool buttonControl = false;
// method to close the claw when the sonar reads 0
// TODO keep the claw closed as needed

bool clawCheck(){
sonarV = SensorValue(sonarC);
if(sonarV == -1){
// skip if registering a -1
}
else if(sonarV < 5){
// if can is within reach
clawFlip = true;
return true;
}
else{
clawFlip = false;
return false;
//motor[clawServo] = clawOpen;
}
}
// shoulder positive value is up, negative is down
// methods to consistently move the shoulder up and down
void shoulderUp(){
motor[shoulderM] = 20;
wait1Msec(500);
motor[shoulderM] = 0;
}
void shoulderDown(){
motor[shoulderM] = -20;
wait1Msec(500);// dropped from 1000
motor[shoulderM] = 0;
}
// for elbow, negative motor is up, positive is down
// method for moving the elbow consistently
void elbowUp(){
motor[elbowM] = -30; // up from 25
wait1Msec(600);
motor[elbowM] = 0;
}
void elbowDown(){
motor[elbowM] = 20;
wait1Msec(750);
motor[elbowM] = 0;
}
// consistently move the arm forward as needed
void reachForward(){
elbowUp();
shoulderDown();
shoulderDown();
}
// double the elbow ups if needed
void reachForwardExtended(){
elbowUp();
elbowUp();

shoulderDown();
shoulderDown();
}
void shoulderReach(){
shoulderDown();
shoulderDown();
motor[elbowM] = 30; // up from 25
wait1Msec(300);
motor[elbowM] = 0;
}
// shoulder motor positive is up, negative is down.
// Starting position is shoulder at -30, elbow at -72// position keeps changing
void startMove(){
//while(SensorValue(shoulderEncoder) > -28 && SensorValue(elbowEncoder) > -28)
while(SensorValue(shoulderEncoder) > -4){
shoulderUp();
}
while(SensorValue(elbowEncoder) > 2){ // should be 6
elbowDown();
}
}
// fix
// Once a can is picked up, this will throw it behind the robot
void throw(){
//shoulder -30 elbow 80
while(SensorValue(shoulderEncoder) > -6){
shoulderUp();
}
while(SensorValue(elbowEncoder) < 130){ // should be 6
elbowUp();
}
clawFlip = false; // moved down, drop the can
}
task main(){
// check if changed to button control
while(buttonControl){//buttonControl
//wait10Msec(10);
writeDebugStream("Shoulder Value: %d\n",SensorValue(shoulderEncoder));
writeDebugStream("Elbow Value: %d\n",SensorValue(elbowEncoder));
sonarV = SensorValue(sonarC);
if(SensorValue(shoulderUpButton) == 1){
shoulderUp();
}
if(SensorValue(shoulderDownButton) == 1){
shoulderDown();
}
if(SensorValue(elbowUpButton) == 1){
elbowUp();

}
if(SensorValue(elbowDownButton) == 1){
elbowDown();
writeDebugStream("button pressed ELBOW: %d\n",SensorValue(elbowEncoder));
}
clawCheck();
if(clawFlip){
writeDebugStream("closing servo\n");
motor[clawServo] = clawClose ;
wait1Msec(30);
//wait1Msec(500);
}
else{
writeDebugStream("opening servo\n");
motor[clawServo] = clawOpen;
wait1Msec(30);
//reachForward();
}
}
// Main Loop for can pick up
int j = 0;
// for each can
for(j ; j < 3 ; j++){
motor[clawServo] = clawOpen;
// move to starting position
startMove();
// log positions for calibration as needed
writeDebugStream("elbow: %d\n",SensorValue(elbowEncoder));
writeDebugStream("shoulder: %d\n",SensorValue(shoulderEncoder));
int i = 0; // should be 0
sonarV = SensorValue(sonarC);
// equation to convert sonar values in to claw distance from the start position
int distance = (int)((sonarV-14.5) / 2);
writeDebugStream("distance: %d\n",distance);
// for distance away, move forward
for(i; i < distance ; i++){
// check if extended reach is needed to stay on target as the arm extends
if(i >= 4){
if(i >=8){
shoulderReach();
}else{
reachForwardExtended();
}
}else{
reachForward();
}
}
// close the claw and throw the can
motor[clawServo] = clawClose;
wait10Msec(50);

throw();
}
// log final positions
writeDebugStream("%d\n",SensorValue(elbowEncoder));
writeDebugStream("%d\n",SensorValue(shoulderEncoder));
}
