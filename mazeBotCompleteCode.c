#pragma config(Sensor, in1, light, sensorReflection)
#pragma config(Sensor, dgtl8, bSwitch1, sensorTouch)
#pragma config(Sensor, dgtl9, bSwitch2, sensorTouch)
#pragma config(Sensor, dgtl10, sonar, sensorSONAR_cm)
#pragma config(Motor, port2, leftMotor, tmotorServoContinuousRotation, openLoop,
driveLeft)
#pragma config(Motor, port3, rightMotor, tmotorServoContinuousRotation, openLoop,
driveRight)
#pragma config(Motor, port4, lightSensor, tmotorServoStandard, openLoop)
#pragma config(Motor, port5, SonarServo, tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//
// initializations
// global distance cutoff for the robot is too close
int cutoff = 25;
int farFront = 55;
// temp Value
int val;
// set the speed for the robot for all code
int lSpeed = 25;
int rSpeed = 27;
int waitTime = 100;




// function to scan for the light, returns the servo value where the light was the highest
int scanLight(){
int countVal;
int endVal = -127;
int lightVal;
int highestLight = 4096;
int highCount;
motor[lightSensor] = countVal;
// loop through whole range of motion starting from the right
for(countVal = 127; countVal > endVal; countVal = countVal - 5){
// Check current light value
lightVal = SensorValue(light);
//Check if new light value is brighter than old brightest light value
if(lightVal + 5 < highestLight){
highestLight = lightVal;
highCount = countVal;
// update highest light position
//lightPos = countVal;
}
// wait at each position for 300 miliseconds
wait1Msec(50);
// move to the new position
motor[lightSensor] = countVal;
}
if(highestLight < 5000){
return(highCount);
}
else{
return(0);
}
}
// turn right
void turnRight(){
motor[leftMotor] = -lSpeed;
motor[rightMotor] = rSpeed;
wait1Msec(850);
motor[leftMotor] = 0;
motor[rightMotor] = 0;
}
// turn left
void turnLeft(){
motor[leftMotor] = lSpeed;
motor[rightMotor] = -rSpeed;
wait1Msec(850);
motor[leftMotor] = 0;
motor[rightMotor] = 0;



Arthur Hernandez
Tuesday October 19th
Autonomous Robotics

}
// move forward
void goForward(){
motor[leftMotor] = lSpeed;
motor[rightMotor] = rSpeed;
wait1Msec(850);
motor[leftMotor] = 0;
motor[rightMotor] = 0;
}
// move backward
void reverse(){
motor[leftMotor] = -lSpeed;
motor[rightMotor] = -rSpeed;
wait1Msec(3*waitTime);
motor[leftMotor] = 0;
motor[rightMotor] = 0;
}
// returns if the servo is close to the wall on the left side,0 if its too close to the wall
// ad something to keep it from decreasing the distance to the left wall in processs
// Add something to check more than one position
int servoCheckLeft(){
motor[SonarServo] = -105;
val = SensorValue(sonar);
// check for special case
if(val == -1){
reverse();
servoCheckLeft();
}
return(val);
}
// check to the right
int servoCheckRight(){
wait1Msec(waitTime/2);
motor[SonarServo] = 110;
wait1Msec(waitTime/2);
val = SensorValue(sonar);
if(val == -1){
reverse();
//reccursion should be removed but should not happen
servoCheckRight();
}

return(val);
}
// check front distances
int servoCheckFront(){


motor[SonarServo] = 0;
val = SensorValue(sonar);
// catch if the servo gives a -1 value
if(val == -1){
reverse();
//reccursion should be removed, new file used instead
servoCheckFront();
val = 0;
}
return(val);
}
// method to check the front whisker sensors
int senseBumps(){
if(SensorValue(bSwitch1) == 1){
turnRight();
return(1);
}
if(SensorValue(bSwitch2) == 1){
turnLeft();
//turnLeft();
//turnLeft();
return(2);
}
return(0);
}
// initialize variables
int lv,rv,fv,lightV;
task main()
{
while(true){
// check for bumps
if(senseBumps() != 0){
continue;
}
wait1Msec(50);
// check servo either side
rv = servoCheckRight();
wait1Msec(50);
rv = servoCheckRight(); // needs twice for some reason
wait1Msec(50);
fv = servoCheckFront();
wait1Msec(75);
lv = servoCheckLeft();
wait1Msec(50);
if(senseBumps() != 0){
continue;

}
if(fv > farFront){
goForward();
continue;
}
else if(lv <= cutoff -3 ){ //turn right and forward if there is a lot of room to the right
turnRight();
goForward();
}
// turn left and forward if there is a lot of room to the right
else if(rv <= cutoff){
turnLeft();
goForward();
//continue;
}
// go forward if possible
else if(fv >= cutoff){
goForward();
continue;
}
// wall all around and turn around
else if(lv < 30 && rv < 30 && fv < 30){
turnLeft();
turnLeft();
turnLeft();
}
else{
reverse();
}
} // end while loop
}// end program
