
#pragma config(Sensor, dgtl1, shoulderUpButton, sensorTouch)
#pragma config(Sensor, dgtl2, shoulderDownButton, sensorTouch)
#pragma config(Sensor, dgtl3, elbowUpButton, sensorTouch)
#pragma config(Sensor, dgtl4, elbowDownButton, sensorTouch)
#pragma config(Sensor, dgtl5, sonarC, sensorSONAR_cm)
#pragma config(Sensor, dgtl7, elbowLimit, sensorTouch)
#pragma config(Sensor, dgtl8, elbowEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl10, shoulderLimit, sensorTouch)
#pragma config(Sensor, dgtl11, shoulderEncoder, sensorQuadEncoder)
#pragma config(Motor, port2, shoulderM, tmotorServoContinuousRotation,
openLoop)
#pragma config(Motor, port3, elbowM, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor, port4, clawServo, tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//
//global variables
// Optical shaft encoder values the arm shouldnt go past
// Shoulder
int sUpperBound = -30;
int sLowerBound = 30;
//Elbow
int eUpperBound = 40;
int eLowerBound = -40;
//Limits for the claw servo
int clawOpen = 125;
int clawClose = -75;
bool clawFlip = false;
int sonarV = 10;
// method to close the claw when the sonar reads 0 to close around a can
bool clawCheck(){
sonarV = SensorValue(sonarC);
if(sonarV == -1){
// Do nothing if reading a -1
}
// check if the sonar distance is less than 5 and close the claw
else if(sonarV < 5){
// clawflip ensures that later in the loop the claw stays in the position
clawFlip = true;
return true;
}
else{
clawFlip = false;

return false;
}
}
// methods to consistently move the manipulator
// shoulder positive value is up, negative is down
void shoulderUp(){
motor[shoulderM] = 20;
wait1Msec(1000);
motor[shoulderM] = 0;
}
void shoulderDown(){
motor[shoulderM] = -20;
wait1Msec(1000);
motor[shoulderM] = 0;
}
// for elbow, negative motor is up, positive is down
void elbowUp(){
motor[elbowM] = 25;
wait1Msec(1000);
motor[elbowM] = 0;
}
void elbowDown(){
motor[elbowM] = -20;
wait1Msec(750);
motor[elbowM] = 0;
}
void reachForward(){
elbowUp();
shoulderDown();
}
// shoulder motor positive is up, negative is down.
// Move the manipulator to the start position
// Starting position is shoulder at -30, elbow at -72
void startMove(){
while(SensorValue(shoulderEncoder) > -28){
writeDebugStream("shoulderup\n");
shoulderUp();
}
while(SensorValue(elbowEncoder) > -60){
elbowDown();
}
}
// Throw the can once its picked up
void throw(){
//shoulder -30 elbow 80
while(SensorValue(shoulderEncoder) > -30){

shoulderUp();
}
while(SensorValue(elbowEncoder)< 70){
elbowDown();
}
}
task main(){
// Loop for button control
while(true){
//wait10Msec(10);
writeDebugStream("Shoulder Value: %d\n",SensorValue(shoulderEncoder));
writeDebugStream("Elbow Value: %d\n",SensorValue(elbowEncoder));
sonarV = SensorValue(sonarC);
if(SensorValue(shoulderUpButton) == 1){
shoulderUp();
}
if(SensorValue(shoulderDownButton) == 1){
shoulderDown();
}
if(SensorValue(elbowUpButton) == 1){
elbowUp();
}
if(SensorValue(elbowDownButton) == 1){
elbowDown();
writeDebugStream("button pressed ELBOW: %d\n",SensorValue(elbowEncoder));
}
clawCheck();
if(clawFlip){
writeDebugStream("closing servo\n");
motor[clawServo] = clawClose ;
wait1Msec(30);
//wait1Msec(500);
}
else{
writeDebugStream("opening servo\n");
motor[clawServo] = clawOpen;
wait1Msec(30);
//reachForward();
}
}
// simple algorithm to pick up a can as it is found. Using the sonar atached to the claw
startMove();
bool switcher = false;
// while the claw doesnt hold a can.
while(!clawCheck()){
// alternates elbow up and shoulder down resulting in reaching directly forward

if(switcher){
elbowUp();
elbowUp();
}
else if(!switcher){
shoulderDown();
}
switcher = !switcher;
}
// when it has a can in the claw,throw
throw();

// Print final values
writeDebugStream("%d\n",SensorValue(elbowEncoder));
writeDebugStream("%d\n",SensorValue(shoulderEncoder));
}
